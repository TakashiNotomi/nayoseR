#' Launch Manual Review Shiny App for Name Matching Candidates
#'
#' This function launches a Shiny interface for manually approving or rejecting
#' name matching candidates generated by `match_names_sbert()`. It loads previously
#' approved and rejected records to skip them from display and shows the full judgment
#' log during the session. Approved results are saved to `nayose_dict.csv`,
#' and rejected ones to `nayose_rejected.csv`.
#'
#' @return None. Launches the Shiny app; results are saved via manual operation.
#' @importFrom shiny fluidPage titlePanel sidebarLayout sidebarPanel sliderInput
#'   actionButton mainPanel DTOutput reactiveVal renderDT observeEvent shinyApp
#'   showNotification NS
#' @importFrom DT datatable renderDT dataTableProxy selectRows
#' @importFrom utils read.csv write.csv
#' @export
launch_nayose_app <- function() {
  ui <- shiny::fluidPage(
    shiny::titlePanel("Manual Review of Name Matching Candidates"),
    shiny::sidebarLayout(
      shiny::sidebarPanel(
        shiny::sliderInput("threshold", "Similarity Threshold", min = 0.5, max = 1, value = 0.75, step = 0.01),
        shiny::actionButton("select_all", "Select All"),
        shiny::actionButton("approve_selected", "Approve Selected"),
        shiny::actionButton("reject_selected", "Reject Selected"),
        shiny::actionButton("save_csv", "Save Results")
      ),
      shiny::mainPanel(
        DT::DTOutput("table"),
        shiny::br(),
        DT::DTOutput("confirmed_table")
      )
    )
  )

  server <- function(input, output, session) {
    # Load original match candidates
    original_df <- utils::read.csv("match_result.csv", stringsAsFactors = FALSE)

    # Prepare confirmed log
    confirmed_data <- data.frame(
      name_a = character(),
      name_b = character(),
      similarity = numeric(),
      status = character(),
      stringsAsFactors = FALSE
    )

    # Load past approved and rejected data
    if (file.exists("nayose_dict.csv")) {
      approved_df <- utils::read.csv("nayose_dict.csv", stringsAsFactors = FALSE)
      approved_df$status <- "approved"
      confirmed_data <- rbind(confirmed_data, approved_df)
    } else {
      approved_df <- data.frame(name_a = character(), name_b = character(), stringsAsFactors = FALSE)
    }

    if (file.exists("nayose_rejected.csv")) {
      rejected_df <- utils::read.csv("nayose_rejected.csv", stringsAsFactors = FALSE)
      rejected_df$status <- "rejected"
      confirmed_data <- rbind(confirmed_data, rejected_df)
    } else {
      rejected_df <- data.frame(name_a = character(), name_b = character(), stringsAsFactors = FALSE)
    }

    # Exclude already judged records
    combined_exclude <- rbind(
      approved_df[, c("name_a", "name_b")],
      rejected_df[, c("name_a", "name_b")]
    )

    filtered_df <- subset(
      original_df,
      !(paste0(name_a, name_b) %in% paste0(combined_exclude$name_a, combined_exclude$name_b))
    )

    match_df <- shiny::reactiveVal(filtered_df)
    confirmed <- shiny::reactiveVal(confirmed_data)

    output$table <- DT::renderDT({
      filtered <- match_df()[match_df()$similarity >= input$threshold, ]
      DT::datatable(filtered, selection = list(mode = "multiple"))
    })

    table_proxy <- DT::dataTableProxy("table")

    shiny::observeEvent(input$select_all, {
      filtered <- match_df()[match_df()$similarity >= input$threshold, ]
      DT::selectRows(table_proxy, seq_len(nrow(filtered)))
    })

    shiny::observeEvent(input$approve_selected, {
      rows <- input$table_rows_selected
      filtered <- match_df()[match_df()$similarity >= input$threshold, ]
      if (length(rows) > 0) {
        selected <- filtered[rows, ]
        selected$status <- "approved"
        confirmed(rbind(confirmed(), selected))

        updated <- match_df()
        for (i in seq_len(nrow(selected))) {
          updated <- updated[!(updated$name_a == selected$name_a[i] & updated$name_b == selected$name_b[i]), ]
        }
        match_df(updated)
      }
    })

    shiny::observeEvent(input$reject_selected, {
      rows <- input$table_rows_selected
      filtered <- match_df()[match_df()$similarity >= input$threshold, ]
      if (length(rows) > 0) {
        selected <- filtered[rows, ]
        selected$status <- "rejected"
        confirmed(rbind(confirmed(), selected))

        updated <- match_df()
        for (i in seq_len(nrow(selected))) {
          updated <- updated[!(updated$name_a == selected$name_a[i] & updated$name_b == selected$name_b[i]), ]
        }
        match_df(updated)
      }
    })

    shiny::observeEvent(input$save_csv, {
      all_confirmed <- confirmed()
      approved <- all_confirmed[all_confirmed$status == "approved", ]
      rejected <- all_confirmed[all_confirmed$status == "rejected", ]

      utils::write.csv(approved, "nayose_dict.csv", row.names = FALSE)
      utils::write.csv(rejected, "nayose_rejected.csv", row.names = FALSE)

      shiny::showNotification("Results saved to nayose_dict.csv and nayose_rejected.csv")
    })

    output$confirmed_table <- DT::renderDT({
      DT::datatable(confirmed())
    })
  }

  shiny::shinyApp(ui, server)
}
